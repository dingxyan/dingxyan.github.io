<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>久矻矻</title>
 <link href="http://http://coolshell.info/atom.xml" rel="self"/>
 <link href="http://http://coolshell.info"/>
 <updated>2017-09-02T08:47:51+00:00</updated>
 <author>
   <name>dxy</name>
   <email>dingxyan@163.com</email>
 </author>

 
 <entry>
   <title>Javascript权威指南学习笔记1：第二章（词法结构）</title>
   <link href="http://http://coolshell.info/blog/2017/08/js%E5%9F%BA%E7%A1%80-2.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/js基础-2</id>
   <content type="html">&lt;h3 id=&quot;js编码&quot;&gt;JS编码&lt;/h3&gt;
&lt;p&gt;JS的编码基于Unicode编码，是ASCII以及Latin-1的超集，支持几乎所有语言；&lt;/p&gt;
&lt;h3 id=&quot;js区分大小写&quot;&gt;js区分大小写&lt;/h3&gt;
&lt;h3 id=&quot;js解析&quot;&gt;js解析&lt;/h3&gt;
&lt;p&gt;JS解析的时候会过滤掉空格，制表符，换页符等；
对于回车符号，如果结尾有分号，会被忽略，否则，会做以下处理：
&lt;strong&gt;如果当前行与下一行不能合在一起被解析，那么当前行会被加上分号&lt;/strong&gt;，例如
&lt;code class=&quot;highlighter-rouge&quot;&gt;
var a  
a  
=  
3  
console.log(a)
&lt;/code&gt;
会被解析为
&lt;code class=&quot;highlighter-rouge&quot;&gt;
var a;  
a=3;  
console.log(a);
&lt;/code&gt;
再如：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
var p = a+b+f  
(c+d).toString()
&lt;/code&gt;
会被解析为
&lt;code class=&quot;highlighter-rouge&quot;&gt;
var p = a+b+f(c+d).toString(); 
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其中有2种情况异常：&lt;/strong&gt;
情况1：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
return  
true 
&lt;/code&gt;
会被解析为
&lt;code class=&quot;highlighter-rouge&quot;&gt;
return;  
true;
&lt;/code&gt;
因此 return 后面不要跟回车；
情况2：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
x  
++  
y
&lt;/code&gt;
会被解析为
&lt;code class=&quot;highlighter-rouge&quot;&gt;
x;  
++y; &lt;/code&gt;
分号可省略，省略有风险。在写组件的时候，往往习惯在开头加一个分号，这样可以防止之前没有分号，导致的解析错误。&lt;/p&gt;
&lt;h3 id=&quot;保留字&quot;&gt;保留字&lt;/h3&gt;
&lt;p&gt;js标识符规定以字母、下划线、$开头；
js有很多保留字，不能用于变量命名，例如 class, const, enum, export, extends, import, super, 以及在严格模式下的保留字interface, implements, let, private, public, yield, package, protected, static, 严格模式下并非保留字但不能用于保留字的 arguments, eval;
总之，高级语言中的保留字基本都被js作为保留字了，尽管js目前不一定使用这些保留字。
出于可移植以及易于书写的考虑，一般用ASCII字母和数字来书写标识符，然而js也是可以解析Unicode字符的，这些不常用。&lt;/p&gt;
&lt;h3 id=&quot;特有全局变量及函数&quot;&gt;特有全局变量及函数&lt;/h3&gt;
&lt;p&gt;js有特定的全局变量及函数，用到的时候再进行总结。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Javascript权威指南学习笔记1：第一章</title>
   <link href="http://http://coolshell.info/blog/2017/08/js%E5%9F%BA%E7%A1%80-1.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/js基础-1</id>
   <content type="html">&lt;p&gt;工作一年，对前端有了一些自己的理解，前端知识太多，于是决定从学习基础知识开始，重新将基础知识进行整理，希望弥补漏洞，并温故知新。&lt;/p&gt;

&lt;p&gt;第一章没有太多核心知识，只是对全书进行一个概括性的总结，从js基础语法入手，逐步介绍如何使用js进行web开发，以及中间包含的各种知识，对这一章的学习可以对整个JS有一个清晰的认识。&lt;/p&gt;

&lt;h3 id=&quot;基础知识篇&quot;&gt;基础知识篇&lt;/h3&gt;
&lt;p&gt;js基本语法，包括变量定义、赋值、运算，基本数据类型、数组、对象、方法，面向对象，条件运算，循环运算，正则；&lt;/p&gt;
&lt;h3 id=&quot;进阶篇&quot;&gt;进阶篇&lt;/h3&gt;
&lt;p&gt;如何将JS应用到Web开发，这里涉及到应用规范，加载规范；如何操作Dom，如何与css交互，如何进行事件处理；调试工具；以及为了解决兼容性并且使用简便而出现的各种库；&lt;/p&gt;
&lt;h3 id=&quot;高级篇&quot;&gt;高级篇&lt;/h3&gt;
&lt;p&gt;与服务端交互；数据存储机制；客户端绘图；新应用；&lt;/p&gt;
&lt;h3 id=&quot;终极篇&quot;&gt;终极篇&lt;/h3&gt;
&lt;p&gt;经过前面的学习，对前端开发应该会有清晰的认识，也可以非常流畅的干活了。&lt;/p&gt;

&lt;p&gt;然而，前端并不仅仅这些，
性能优化，模块化一直都是在开发过程中不懈追求的，而平时的学习也应当不断总结不断积累，不断扩展知识面；而今，如React、vue、angular等各个框架日新月异，h5也带来了很多新颖特性，总之，前段就是一条不断学习之路。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我所知道的iframe</title>
   <link href="http://http://coolshell.info/blog/2017/08/html-iframe.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/html-iframe</id>
   <content type="html">&lt;p&gt;iframe在前端开发过程中应用广泛，其主要是将一个页面作为整体引用到一个页面中。一般有以下应用场景&lt;/p&gt;

&lt;h3 id=&quot;1-公司应用系统开发&quot;&gt;1. 公司应用系统开发&lt;/h3&gt;
&lt;p&gt;一般会有一个左侧列表，作为一个框架，每一个目录引用独立的html页面，这样便于每一个页面独立开发。&lt;/p&gt;

&lt;h3 id=&quot;2-引入第三方&quot;&gt;2. 引入第三方&lt;/h3&gt;
&lt;p&gt;当页面需要从第三方引入模块的时候，往往会使用iframe，保证原始页面与第三方之间不冲突。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来，我们聊一聊，iframe中，如何进行事件的绑定&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;iframe的事件绑定&quot;&gt;iframe的事件绑定&lt;/h2&gt;
&lt;h3 id=&quot;1-事件绑定&quot;&gt;1. 事件绑定&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$('iframe').load(function(){
	$('iframe').contents().click(function(){console.log(&quot;test1&quot;)});//会为所有iframe绑定事件
	//document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow.document.onclick=function(){console.log(&quot;test”)}//按照序号为每一个iframe绑定事件
	//document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow.onclick=function(){console.log(&quot;test”)}//同上
});
&lt;/code&gt;
contentWindow用于获取iframe内容，原生写法，这个属性是只读的，iframe本身不能绑定事件，要获取其内容绑定事件，
$(‘iframe’).find(‘body’)//undefined
$(‘iframe’).contents().find(‘body’)//ok
另外，需要等待iframe load成功之后再绑定事件，否则事件绑定失败&lt;/p&gt;
&lt;h3 id=&quot;2-事件委托&quot;&gt;2. 事件委托&lt;/h3&gt;
&lt;p&gt;无法实现，因为事件冒泡到自己的document就会停止，不会继续向上，所以在外层无法检测内层的事件冒泡。&lt;/p&gt;
&lt;h3 id=&quot;3-each&quot;&gt;3. each&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(document).ready(function () {
    $(&quot;iframe&quot;).each(function () {
        var iframe = $(this);
        iframe.on(&quot;load&quot;, function () { //保证完全加载完成
            console.log(iframe.contents())
            iframe.contents().click(function (event) {
                iframe.trigger(&quot;click&quot;);
            });
        });
        iframe.click(function () {
            console.log(3);
        });
    });
});
&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-伪类&quot;&gt;4. 伪类&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.g-content:after{
      content:&quot;&quot;;
      position:absolute;
      z-index:1;
      width:100%;
      height:100%;
      left:0;
      top:0;
}
$(&quot;#j_content&quot;).on(&quot;click&quot;,function(){
    console.log(&quot;test&quot;)
})
&lt;/code&gt;
给iframe的父容器添加伪类after，并给其绑定事件，缺点是，ifrmame内部的所有事件都会被遮挡，不会响应。&lt;/p&gt;

</content>
 </entry>
 
 
</feed>