<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>久矻矻</title>
 <link href="http://http://coolshell.info/atom.xml" rel="self"/>
 <link href="http://http://coolshell.info"/>
 <updated>2017-09-22T12:13:56+00:00</updated>
 <author>
   <name>dxy</name>
   <email>dingxyan@163.com</email>
 </author>

 
 <entry>
   <title>js 各种宽高</title>
   <link href="http://http://coolshell.info/blog/2017/09/js-width&height.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/js-width&height</id>
   <content type="html">&lt;h2 id=&quot;1-elementclientwidth-elementclientheight&quot;&gt;1. Element.clientWidth Element.clientHeight&lt;/h2&gt;
&lt;p&gt;用于获取元素宽高，例如 document.body.clientWidth，因此，如果页面没有内容，那么获取到的height为0；
下图展示了clientWidth及clientHeight所表示的元素的计算方法&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;    
&lt;img src=&quot;/images/Dimensions-client.png&quot; /&gt;
&lt;/div&gt;
&lt;h2 id=&quot;2-elementscrollwidth&quot;&gt;2. Element.scrollWidth&lt;/h2&gt;
&lt;p&gt;比clientWidth多滚动条的宽度&lt;/p&gt;
&lt;h2 id=&quot;3-elementscrollheight&quot;&gt;3. Element.scrollHeight&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;    
	&lt;img src=&quot;/images/scrollHeight.png&quot; /&gt;
&lt;/div&gt;
&lt;h2 id=&quot;4-elementoffsetwidth-elementoffsetheight&quot;&gt;4. Element.offsetWidth Element.offsetHeight&lt;/h2&gt;
&lt;p&gt;比clientWidth多border的宽度&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;    
&lt;img src=&quot;/images/Dimensions-offset.png&quot; /&gt;
&lt;/div&gt;
&lt;h2 id=&quot;5-windowscreenwidth&quot;&gt;5. window.screen.width&lt;/h2&gt;
&lt;p&gt;获取窗口分辨率宽高，window.screen.availWidth为可见区域的&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Note that not all of the width given by this property may be available to the window itself. When other widgets occupy space that cannot be used by the window object, there is a difference in window.screen.width and window.screen.availWidth. See also window.screen.height.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;6-inner-outer&quot;&gt;6. inner outer&lt;/h2&gt;
&lt;p&gt;window.innerWidth, window.innerHeight, 获取窗口可见区域宽高；
window.outerWidth, window.outerHeight, 获取窗口宽高，包括滚动条、边框、控制区域&lt;/p&gt;
&lt;h2 id=&quot;7-jq&quot;&gt;7. jq&lt;/h2&gt;
&lt;p&gt;$(window).width(), $(window).height() 获取窗口宽高；值同于window.innerWidth, window.innerHeight，不包含padding；
$(document).width(), $(document).height() 获取文档对象宽高，resize之后不变，当文档对象实际高度小于窗口高度的时候，会返回窗口高度&lt;/p&gt;
&lt;h2 id=&quot;8-获取元素位置信息&quot;&gt;8. 获取元素位置信息&lt;/h2&gt;
&lt;p&gt;Element.getBoundingClientRect()
Element.getClientRects()&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考MDN开发者文档&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>手机键盘“开始”触发搜索</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-search-keybord.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-search-keybord</id>
   <content type="html">&lt;p&gt;html:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;form id=&quot;search&quot; action=&quot;#&quot;&amp;gt;
	&amp;lt;input placeholder=&quot;&quot; type=&quot;search&quot; name=&quot;shops&quot; id=&quot;shopName&quot;&amp;gt;
	&amp;lt;div class=&quot;search-btn&quot;&amp;gt;&amp;lt;span id=&quot;getShops&quot; class=&quot;search-icon&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;js&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('#getShops').on('click', function(event){
    var name = $.trim($(&quot;#shopName&quot;).val());
    //code
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>百度地图及高德地图一些使用</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-map.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-map</id>
   <content type="html">&lt;h2 id=&quot;百度地图&quot;&gt;百度地图&lt;/h2&gt;
&lt;h4 id=&quot;初始化方法&quot;&gt;初始化方法：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;amp;ak=VBf5****************&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;使用script标签引入到页面，其中ak是需要在网站上申请的。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;map = new BMap.Map(&quot;map&quot;);//初始化
map.centerAndZoom(new BMap.Point(116.417854,39.921988), 15);//设定地图层级及中心
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注：初始化的时候，地图放置区域的dom必须是存在的，而且宽高确定的，否则地图无法显示。&lt;/p&gt;
&lt;h4 id=&quot;添加标注&quot;&gt;添加标注&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var marker = new BMap.Marker(new BMap.Point(baidu_lat,baidu_lon));  // 创建标注
map.addOverlay(marker);// 将标注添加到地图中
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;添加自定义标注&quot;&gt;添加自定义标注&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var iconLocal = new BMap.Icon(&quot;img url&quot;, new BMap.Size(19, 19), {  
    offset: new BMap.Size(8, 16), // 指定定位位置  
    imageOffset: new BMap.Size(-132, -109), // 设置图片偏移
    imageSize: new BMap.Size(200,200)
});
var markerLocal = new BMap.Marker(new BMap.Point(postion.lng,postion.lat),{icon: iconLocal});  // 创建标注
map.addOverlay(markerLocal);// 将标注添加到地图中
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注：百度地图的marker每次不能加载太多，会特别卡，因此在每次添加新的之前，最好将上次添加的取消	&lt;code class=&quot;highlighter-rouge&quot;&gt;map.removeOverlay(marker);&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;异步加载&quot;&gt;异步加载&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function loadMap(){
    var script = document.createElement(&quot;script&quot;);
    script.type = &quot;text/javascript&quot;;
    script.src = &quot;http://api.map.baidu.com/api?v=2.0&amp;amp;ak=VBf5eApmFMSBKuWmDGr0icUt40qRTI4c&amp;amp;callback=testInit&quot;;
    document.body.appendChild(script);
}
//配合地图初始化
function testInit(){}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;异步加载的时候，如果希望js加载完成便执行初始化地图的方法，那么需要在链接后面加callback，而callback的值便是js加载完成后要执行的方法，并且这个方法需要时全局方法，否则会报错；然而经过测试，callback的值可以是一个非全局的方法，这个方法不会被调用，此时js也可以加载成功的（也许这是一个bug）。&lt;/p&gt;

&lt;h4 id=&quot;添加信息窗口&quot;&gt;添加信息窗口&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var opts = {// 信息窗口参数
    width : 300,
    offset: {height:-25,width:0},
    enableCloseOnClick: false
};
map.closeInfoWindow();
//先关掉上一个，否则如果你每次改变信息窗口的时候，重新将当前的位置设为中心的话，那么信息窗口的位置等于没有改拜年，这个时候信息窗口会闪一下
var point = new BMap.Point(baidu_lat,baidu_lon);
var infoHtml = me.getInfoHtml(index);//信息窗口的内容支持html字符串

var infoWindow = new BMap.InfoWindow(infoHtml,opts);// 创建信息窗口对象 

infoWindow.addEventListener(&quot;open&quot;,function(){
    clearTimeout(time2);
    $(&quot;#qrcode&quot;).qrcode(qrcodeurl);//添加二维码
    time2 = setTimeout(function(){
        var h1 = $(&quot;.BMap_center&quot;).height();
        var height = 50 + h1;
        $(&quot;.BMap_pop&quot;).css({&quot;width&quot;:&quot;332px&quot;,&quot;height&quot;:height+&quot;px&quot;});
    },100)
})//为什么会有这段代码，下面解释
map.centerAndZoom(point,Data.zoom);

clearTimeout(time);
time = setTimeout(function(){
    map.openInfoWindow(infoWindow,point); //开启信息窗口，同样为了防止上面说的闪一下，延迟一点开启
},300);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;为什么会有上面那段代码呢，有2个原因，这里解释：
原因一，目的是为了在信息窗口显示二维码，信息窗口的生成是需要时间的，那么如果先生成二维码，此时并没有信息窗口的dom，会出现信息窗口先打开并没有加载上二维码的情况，而信息窗口打开之后再生产二维码，一来需要监听信息窗口打开事件，而来此时信息窗口会先是有一块空白，不好看，所以需要，在信息窗口创建完毕，还未打开的时候，将二维码写入；
原因二，百度地图默认的信息窗口，是由几张图片以及中间的一块内容区域拼成的，这样有个极大的问题，对于一些分辨率低的显示设备，在拼接处会有一条条的线，像是屏幕裂掉的，而且更加坑的是，整个信息窗口，本身是在一个dom中的，但是这个dom没有宽高！！没有宽高！！，所以，给整个信息窗口设置背景色也不行，所以，在每次信息窗口加载完成并打开的时候，计算整个信息窗口的宽高，然后再给其设置背景色，这里的open事件是打开事件，但并不是只打开后，而是打开中，所以setTimeout一下，窗口应该打开了，可以计算得到宽高了（加一个大大的无语😓）。&lt;/p&gt;

&lt;p&gt;注：百度地图提供的信息窗口有最小宽高，如果在手机上使用，非常大，而且信息窗口不能自定义样式，非常之坑，因此如果你要美化好看，需要使用自定义的。&lt;/p&gt;
&lt;h4 id=&quot;根据经纬度获取城市信息&quot;&gt;根据经纬度获取城市信息&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var postion = {&quot;lng&quot;:116.417854,&quot;lat&quot;:39.921988};
var gc = new BMap.Geocoder();
gc.getLocation(new BMap.Point(postion.lng,postion.lat), function(rs){
    var addComp = rs.addressComponents;
    alert(addComp.province + &quot;, &quot; + addComp.city + &quot;, &quot; + addComp.district + &quot;, &quot; + addComp.street + &quot;, &quot; + addComp.streetNumber);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;高德地图&quot;&gt;高德地图&lt;/h2&gt;

&lt;h4 id=&quot;初始化&quot;&gt;初始化&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.4.0&amp;amp;key=您申请的key值&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;同样需要先申请key。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var map = new AMap.Map('map', {
    resizeEnable: true,
    zoom:11,
    center: [116.397428, 39.90923]
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;添加marker&quot;&gt;添加marker&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var marker = new AMap.Marker({
    icon: &quot;http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png&quot;,
    position: [116.405467, 39.907761]
});
marker.setMap(map);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;添加信息窗口-1&quot;&gt;添加信息窗口&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;infoWindow = new AMap.InfoWindow({
   content: info.join(&quot;&amp;lt;br&amp;gt;&quot;)  //使用默认信息窗体框样式，显示信息内容
});
infoWindow.open(map, [116.480983, 39.989628]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;高德地图用的少，目前还没发现什么坑，遇到了会继续补充，而且其官网讲解的非常清楚；
个人觉得高德地图比百度地图调用关系清楚，文档也更清楚（也许是因为抄的google的缘故，哈哈哈😄）&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>img及background-image</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-img.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-img</id>
   <content type="html">&lt;h3 id=&quot;1-高度&quot;&gt;1. 高度&lt;/h3&gt;
&lt;p&gt;图片可以把容器高度撑起来，而背景图不可以，对于背景图，如果不设置高度，那么宽高都是0；&lt;/p&gt;
&lt;p&gt;对于img，不设置宽高的时候，会全部展示，并出现滚动条；&lt;/p&gt;
&lt;p&gt;对于背景图，不设置宽高会不展示，设置宽高之后会在设定的区域内展示;&lt;/p&gt;
&lt;p&gt;对于背景图，如果高设置为100%，那么需要position为absolute或者fixed（宽为100%，高为定植的时候不需要);&lt;/p&gt;

&lt;h3 id=&quot;2-长按保存&quot;&gt;2. 长按保存&lt;/h3&gt;
&lt;p&gt;在手机端，img可以长按保存，而背景图不可以；&lt;/p&gt;

&lt;h3 id=&quot;3-白边&quot;&gt;3. 白边&lt;/h3&gt;
&lt;p&gt;对于img及背景图，都有可能会出现白边问题，一般有2种解决方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;margin，padding都为0，图片display设置为block，这是一种常规的解决方案，如果解决不了，那么就采用方案2；&lt;/li&gt;
  &lt;li&gt;设置一个背景色跟图片色值相同，这种方案也可以用于解决一些尺寸不匹配问题，例如在电视端，可以获取到的分辨率一般为1920*1080，然而对于一些浏览器差异or bug导致的差几像素，都有可能会出现白边，所以，最好给一个跟图片颜色差不多的底色，这样会是某一个颜色的边，而非白边；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-float-bug&quot;&gt;4. float bug&lt;/h3&gt;
&lt;p&gt;浏览器有个bug，当图片容器浮动的时候，会导致图片位置有问题，解决方法，设置图片的display为block；&lt;/p&gt;

&lt;h3 id=&quot;5-background-image&quot;&gt;5. background image&lt;/h3&gt;
&lt;p&gt;背景图默认会repeat，因此不想重复的话，需要设置为no-repeat;
背景图一般需要设置background-size, cover会充满屏幕，超出的一部分裁掉，而contain会按照能容得下屏幕的宽或者高展示，另外一个按比例压缩；
雪碧图在h5中使用，例如，雪碧图尺寸为200px*200px, 若html的font-size为fontsize，此时一般设置background-size: 200/fontsize 200/fontsize，而background-position: x/fontsize y/fontsize;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>H5 Center</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-center.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-center</id>
   <content type="html">
&lt;p&gt;上下左右居中&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>h5获取定位</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-location.html"/>
   <updated>2017-09-14T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-location</id>
   <content type="html">&lt;h4 id=&quot;方法1-原声js获取定位&quot;&gt;方法1: 原声js获取定位&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getLocation(){ 
	if (navigator.geolocation){
		navigator.geolocation.getCurrentPosition(showPosition,showError);
	}else{ 
		$(&quot;#content&quot;).html(&quot;浏览器不支持地理定位。&quot;); 
	} 
}
function showPosition(position){
	var lat = position.coords.latitude; //纬度 
	var lag = position.coords.longitude; //经度 
	$(&quot;#content&quot;).html('纬度:'+lat+',经度:'+lag); 
}
function showError(error){
	switch(error.code) { 
		case error.PERMISSION_DENIED: 
			$(&quot;#content&quot;).html(&quot;定位失败,用户不允许地理定位&quot;); 
			break; 
		case error.POSITION_UNAVAILABLE: 
			$(&quot;#content&quot;).html(&quot;无法获取当前位置&quot;); 
			break; 
		case error.TIMEOUT: 
			$(&quot;#content&quot;).html(&quot;定位失败,请求获取用户位置超时&quot;); 
			break; 
		case error.UNKNOWN_ERROR: 
			$(&quot;#content&quot;).html(&quot;定位失败,定位系统失效&quot;); 
			break; 
	}
}
getLocation();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;局限：ios 10.0以上系统需要https协议才支持。&lt;/p&gt;
&lt;h4 id=&quot;方法2-百度地图获取经测试安卓苹果都可以&quot;&gt;方法2: 百度地图获取，经测试，安卓苹果都可以&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var map = new BMap.Map(&quot;content&quot;);
var point = new BMap.Point(116.331398,39.897445);
map.centerAndZoom(point,12);

var geolocation = new BMap.Geolocation();
geolocation.getCurrentPosition(function(r){
	if(this.getStatus() == BMAP_STATUS_SUCCESS){
		var mk = new BMap.Marker(r.point);
		map.addOverlay(mk);
		map.panTo(r.point);
		$(&quot;#postion&quot;).html('您的位置：'+r.point.lng+','+r.point.lat);
	}
	else {
		$(&quot;#postion&quot;).html('failed'+this.getStatus());
	}
},{enableHighAccuracy: true})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;手机定位都是根据GPS，并且需要用户允许定位，而目前pc端一般无GPS，那么他是如何定位的呢？
主要有以下几种说法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;根据ip获取定位，也就是说与运营商合作，精准到每个ip区段，获取每个区段定位（我觉得不太可能这么简单，没有GPS怎么可能准确定位）；&lt;/li&gt;
  &lt;li&gt;你手机安装了百度相关app，当使用这些软件并允许定位的时候，手机默默的提交了定位信息，而pc通过路由器偷偷的从手机获取了你的定位信息（我觉得有可能，如果是真的，真的很流氓）；&lt;/li&gt;
  &lt;li&gt;大数据，你的手机使用百度相关app上网，并且允许定位，每次都会提交ip信息及定位信息，那么该ip段及对应的位置信息会被记录，并且不断更新，那么便可以通过ip为你准确定位（更愿意相信这种方式）。
具体原理未考证，以上都是猜测，希望大神解惑。
不管是什么，于互联网时代，我们还有多少隐私？&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Javascript权威指南学习笔记1：第三章</title>
   <link href="http://http://coolshell.info/blog/2017/09/js%E5%9F%BA%E7%A1%80-3.html"/>
   <updated>2017-09-13T00:00:00+00:00</updated>
   <id>/blog/2017/09/js基础-3</id>
   <content type="html">&lt;h1&gt;#&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;js浮点数
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a=0.3-0.2;
var b=0.4-0.3;
a==b//false
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;常用Math
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Math.pow(2,23);//2的23次方
Math.round(0.7);//四舍五入
Math.ceil(0.7);//向上取整
Math.floor(0.7);//向下取整
Math.abs(-5);//绝对值
Math.max(x,y,z);//
Math.min(x,y,z);//
Math.random();//
Math.PI;//
Math.E;//
Math.sqrt();//
Math.sin(0);//
Math.log(10);//
Math.log(100)/Math.LN10;//
Math.exp();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Javascript权威指南学习笔记1：第二章（词法结构）</title>
   <link href="http://http://coolshell.info/blog/2017/08/js%E5%9F%BA%E7%A1%80-2.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/js基础-2</id>
   <content type="html">&lt;h3 id=&quot;js编码&quot;&gt;JS编码&lt;/h3&gt;
&lt;p&gt;JS的编码基于Unicode编码，是ASCII以及Latin-1的超集，支持几乎所有语言；&lt;/p&gt;
&lt;h3 id=&quot;js区分大小写&quot;&gt;js区分大小写&lt;/h3&gt;
&lt;h3 id=&quot;js解析&quot;&gt;js解析&lt;/h3&gt;
&lt;p&gt;JS解析的时候会过滤掉空格，制表符，换页符等；
对于回车符号，如果结尾有分号，会被忽略，否则，会做以下处理：
&lt;strong&gt;如果当前行与下一行不能合在一起被解析，那么当前行会被加上分号&lt;/strong&gt;，例如&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a  
a  
=  
3  
console.log(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会被解析为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a;  
a=3;  
console.log(a);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var p = a+b+f  
(c+d).toString()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会被解析为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var p = a+b+f(c+d).toString(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;其中有2种情况异常：&lt;/strong&gt;
情况1：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return  
true 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会被解析为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return;  
true;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;因此 return 后面不要跟回车；
情况2：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x  
++  
y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会被解析为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x;  
++y;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;分号可省略，省略有风险。在写组件的时候，往往习惯在开头加一个分号，这样可以防止之前没有分号，导致的解析错误。&lt;/p&gt;
&lt;h3 id=&quot;保留字&quot;&gt;保留字&lt;/h3&gt;
&lt;p&gt;js标识符规定以字母、下划线、$开头；
js有很多保留字，不能用于变量命名，例如 class, const, enum, export, extends, import, super, 以及在严格模式下的保留字interface, implements, let, private, public, yield, package, protected, static, 严格模式下并非保留字但不能用于保留字的 arguments, eval;
总之，高级语言中的保留字基本都被js作为保留字了，尽管js目前不一定使用这些保留字。
出于可移植以及易于书写的考虑，一般用ASCII字母和数字来书写标识符，然而js也是可以解析Unicode字符的，这些不常用。&lt;/p&gt;
&lt;h3 id=&quot;特有全局变量及函数&quot;&gt;特有全局变量及函数&lt;/h3&gt;
&lt;p&gt;js有特定的全局变量及函数，用到的时候再进行总结。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Javascript权威指南学习笔记1：第一章</title>
   <link href="http://http://coolshell.info/blog/2017/08/js%E5%9F%BA%E7%A1%80-1.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/js基础-1</id>
   <content type="html">&lt;p&gt;工作一年，对前端有了一些自己的理解，前端知识太多，于是决定从学习基础知识开始，重新将基础知识进行整理，希望弥补漏洞，并温故知新。&lt;/p&gt;

&lt;p&gt;第一章没有太多核心知识，只是对全书进行一个概括性的总结，从js基础语法入手，逐步介绍如何使用js进行web开发，以及中间包含的各种知识，对这一章的学习可以对整个JS有一个清晰的认识。&lt;/p&gt;

&lt;h3 id=&quot;基础知识篇&quot;&gt;基础知识篇&lt;/h3&gt;
&lt;p&gt;js基本语法，包括变量定义、赋值、运算，基本数据类型、数组、对象、方法，面向对象，条件运算，循环运算，正则；&lt;/p&gt;
&lt;h3 id=&quot;进阶篇&quot;&gt;进阶篇&lt;/h3&gt;
&lt;p&gt;如何将JS应用到Web开发，这里涉及到应用规范，加载规范；如何操作Dom，如何与css交互，如何进行事件处理；调试工具；以及为了解决兼容性并且使用简便而出现的各种库；&lt;/p&gt;
&lt;h3 id=&quot;高级篇&quot;&gt;高级篇&lt;/h3&gt;
&lt;p&gt;与服务端交互；数据存储机制；客户端绘图；新应用；&lt;/p&gt;
&lt;h3 id=&quot;终极篇&quot;&gt;终极篇&lt;/h3&gt;
&lt;p&gt;经过前面的学习，对前端开发应该会有清晰的认识，也可以非常流畅的干活了。&lt;/p&gt;

&lt;p&gt;然而，前端并不仅仅这些，
性能优化，模块化一直都是在开发过程中不懈追求的，而平时的学习也应当不断总结不断积累，不断扩展知识面；而今，如React、vue、angular等各个框架日新月异，h5也带来了很多新颖特性，总之，前段就是一条不断学习之路。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我所知道的iframe</title>
   <link href="http://http://coolshell.info/blog/2017/08/html-iframe.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/html-iframe</id>
   <content type="html">&lt;p&gt;iframe在前端开发过程中应用广泛，其主要是将一个页面作为整体引用到一个页面中。一般有以下应用场景&lt;/p&gt;

&lt;h3 id=&quot;1-公司应用系统开发&quot;&gt;1. 公司应用系统开发&lt;/h3&gt;
&lt;p&gt;一般会有一个左侧列表，作为一个框架，每一个目录引用独立的html页面，这样便于每一个页面独立开发。&lt;/p&gt;

&lt;h3 id=&quot;2-引入第三方&quot;&gt;2. 引入第三方&lt;/h3&gt;
&lt;p&gt;当页面需要从第三方引入模块的时候，往往会使用iframe，保证原始页面与第三方之间不冲突。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来，我们聊一聊，iframe中，如何进行事件的绑定&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;iframe的事件绑定&quot;&gt;iframe的事件绑定&lt;/h2&gt;
&lt;h3 id=&quot;1-事件绑定&quot;&gt;1. 事件绑定&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-$('iframe').load(function(){&quot;&gt;	$('iframe').contents().click(function(){console.log(&quot;test1&quot;)});//会为所有iframe绑定事件
	//document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow.document.onclick=function(){console.log(&quot;test”)}//按照序号为每一个iframe绑定事件
	//document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow.onclick=function(){console.log(&quot;test”)}//同上
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;contentWindow用于获取iframe内容，原生写法，这个属性是只读的，iframe本身不能绑定事件，要获取其内容绑定事件，
$(‘iframe’).find(‘body’)//undefined
$(‘iframe’).contents().find(‘body’)//ok
另外，需要等待iframe load成功之后再绑定事件，否则事件绑定失败&lt;/p&gt;
&lt;h3 id=&quot;2-事件委托&quot;&gt;2. 事件委托&lt;/h3&gt;
&lt;p&gt;无法实现，因为事件冒泡到自己的document就会停止，不会继续向上，所以在外层无法检测内层的事件冒泡。&lt;/p&gt;
&lt;h3 id=&quot;3-each&quot;&gt;3. each&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(function () {
    $(&quot;iframe&quot;).each(function () {
        var iframe = $(this);
        iframe.on(&quot;load&quot;, function () { //保证完全加载完成
            console.log(iframe.contents())
            iframe.contents().click(function (event) {
                iframe.trigger(&quot;click&quot;);
            });
        });
        iframe.click(function () {
            console.log(3);
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;4-伪类&quot;&gt;4. 伪类&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.g-content:after{
      content:&quot;&quot;;
      position:absolute;
      z-index:1;
      width:100%;
      height:100%;
      left:0;
      top:0;
}
$(&quot;#j_content&quot;).on(&quot;click&quot;,function(){
    console.log(&quot;test&quot;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;给iframe的父容器添加伪类after，并给其绑定事件，缺点是，ifrmame内部的所有事件都会被遮挡，不会响应。&lt;/p&gt;

</content>
 </entry>
 
 
</feed>