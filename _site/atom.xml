<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>久矻矻</title>
 <link href="http://http://coolshell.info/atom.xml" rel="self"/>
 <link href="http://http://coolshell.info"/>
 <updated>2017-09-22T08:00:46+00:00</updated>
 <author>
   <name>dxy</name>
   <email>dingxyan@163.com</email>
 </author>

 
 <entry>
   <title>js 各种宽高</title>
   <link href="http://http://coolshell.info/blog/2017/09/js-width&height.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/js-width&height</id>
   <content type="html">&lt;h2 id=&quot;1-elementclientwidth-elementclientheight&quot;&gt;1. Element.clientWidth Element.clientHeight&lt;/h2&gt;
&lt;p&gt;用于获取元素宽高，例如 document.body.clientWidth，因此，如果页面没有内容，那么获取到的height为0；
下图展示了clientWidth及clientHeight所表示的元素的计算方法&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;    
&lt;img src=&quot;/images/Dimensions-client.png&quot; /&gt;
&lt;/div&gt;
&lt;h2 id=&quot;2-elementscrollwidth&quot;&gt;2. Element.scrollWidth&lt;/h2&gt;
&lt;p&gt;比clientWidth多滚动条的宽度&lt;/p&gt;
&lt;h2 id=&quot;3-elementscrollheight&quot;&gt;3. Element.scrollHeight&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;    
	&lt;img src=&quot;/images/scrollHeight.png&quot; /&gt;
&lt;/div&gt;
&lt;h2 id=&quot;4-elementoffsetwidth-elementoffsetheight&quot;&gt;4. Element.offsetWidth Element.offsetHeight&lt;/h2&gt;
&lt;p&gt;比clientWidth多border的宽度&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;    
&lt;img src=&quot;/images/Dimensions-offset.png&quot; /&gt;
&lt;/div&gt;
&lt;h2 id=&quot;5-windowscreenwidth&quot;&gt;5. window.screen.width&lt;/h2&gt;
&lt;p&gt;获取窗口分辨率宽高，window.screen.availWidth为可见区域的&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Note that not all of the width given by this property may be available to the window itself. When other widgets occupy space that cannot be used by the window object, there is a difference in window.screen.width and window.screen.availWidth. See also window.screen.height.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;6-inner-outer&quot;&gt;6. inner outer&lt;/h2&gt;
&lt;p&gt;window.innerWidth, window.innerHeight, 获取窗口可见区域宽高；
window.outerWidth, window.outerHeight, 获取窗口宽高，包括滚动条、边框、控制区域&lt;/p&gt;
&lt;h2 id=&quot;7-jq&quot;&gt;7. jq&lt;/h2&gt;
&lt;p&gt;$(window).width(), $(window).height() 获取窗口宽高；值同于window.innerWidth, window.innerHeight，不包含padding；
$(document).width(), $(document).height() 获取文档对象宽高，resize之后不变，当文档对象实际高度小于窗口高度的时候，会返回窗口高度&lt;/p&gt;
&lt;h2 id=&quot;8-获取元素位置信息&quot;&gt;8. 获取元素位置信息&lt;/h2&gt;
&lt;p&gt;Element.getBoundingClientRect()
Element.getClientRects()&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考MDN开发者文档&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>H5 Search Keybord</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-search-keybord.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-search-keybord</id>
   <content type="html">&lt;p&gt;手机键盘“开始”触发搜索&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>百度地图及高德地图一些使用记录</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-map.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-map</id>
   <content type="html">&lt;p&gt;百度地图及高德地图，调用，使用，反GEo&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>img及background-image差异</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-img.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-img</id>
   <content type="html">&lt;p&gt;####图片及背景图的差异&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;高度
图片可以把容器高度撑起来，而背景图不可以，对于背景图，如果不设置高度，那么宽高都是0；&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>H5 Center</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-center.html"/>
   <updated>2017-09-22T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-center</id>
   <content type="html">&lt;p&gt;上下左右居中&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>h5获取定位</title>
   <link href="http://http://coolshell.info/blog/2017/09/h5-location.html"/>
   <updated>2017-09-14T00:00:00+00:00</updated>
   <id>/blog/2017/09/h5-location</id>
   <content type="html">&lt;h4 id=&quot;方法1-原声js获取定位&quot;&gt;方法1: 原声js获取定位&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getLocation(){ 
	if (navigator.geolocation){
		navigator.geolocation.getCurrentPosition(showPosition,showError);
	}else{ 
		$(&quot;#content&quot;).html(&quot;浏览器不支持地理定位。&quot;); 
	} 
}
function showPosition(position){
	var lat = position.coords.latitude; //纬度 
	var lag = position.coords.longitude; //经度 
	$(&quot;#content&quot;).html('纬度:'+lat+',经度:'+lag); 
}
function showError(error){
	switch(error.code) { 
		case error.PERMISSION_DENIED: 
			$(&quot;#content&quot;).html(&quot;定位失败,用户不允许地理定位&quot;); 
			break; 
		case error.POSITION_UNAVAILABLE: 
			$(&quot;#content&quot;).html(&quot;无法获取当前位置&quot;); 
			break; 
		case error.TIMEOUT: 
			$(&quot;#content&quot;).html(&quot;定位失败,请求获取用户位置超时&quot;); 
			break; 
		case error.UNKNOWN_ERROR: 
			$(&quot;#content&quot;).html(&quot;定位失败,定位系统失效&quot;); 
			break; 
	}
}
getLocation();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;局限：ios 10.0以上系统需要https协议才支持。&lt;/p&gt;
&lt;h4 id=&quot;方法2-百度地图获取经测试安卓苹果都可以&quot;&gt;方法2: 百度地图获取，经测试，安卓苹果都可以&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var map = new BMap.Map(&quot;content&quot;);
var point = new BMap.Point(116.331398,39.897445);
map.centerAndZoom(point,12);

var geolocation = new BMap.Geolocation();
geolocation.getCurrentPosition(function(r){
	if(this.getStatus() == BMAP_STATUS_SUCCESS){
		var mk = new BMap.Marker(r.point);
		map.addOverlay(mk);
		map.panTo(r.point);
		$(&quot;#postion&quot;).html('您的位置：'+r.point.lng+','+r.point.lat);
	}
	else {
		$(&quot;#postion&quot;).html('failed'+this.getStatus());
	}
},{enableHighAccuracy: true})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;手机定位都是根据GPS，并且需要用户允许定位，而目前pc端一般无GPS，那么他是如何定位的呢？
主要有以下几种说法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;根据ip获取定位，也就是说与运营商合作，精准到每个ip区段，获取每个区段定位（我觉得不太可能这么简单，没有GPS怎么可能准确定位）；&lt;/li&gt;
  &lt;li&gt;你手机安装了百度相关app，当使用这些软件并允许定位的时候，手机默默的提交了定位信息，而pc通过路由器偷偷的从手机获取了你的定位信息（我觉得有可能，如果是真的，真的很流氓）；&lt;/li&gt;
  &lt;li&gt;大数据，你的手机使用百度相关app上网，并且允许定位，每次都会提交ip信息及定位信息，那么该ip段及对应的位置信息会被记录，并且不断更新，那么便可以通过ip为你准确定位（更愿意相信这种方式）。
具体原理未考证，以上都是猜测，希望大神解惑。
不管是什么，于互联网时代，我们还有多少隐私？&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Javascript权威指南学习笔记1：第三章</title>
   <link href="http://http://coolshell.info/blog/2017/09/js%E5%9F%BA%E7%A1%80-3.html"/>
   <updated>2017-09-13T00:00:00+00:00</updated>
   <id>/blog/2017/09/js基础-3</id>
   <content type="html">&lt;h1&gt;#&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;js浮点数
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a=0.3-0.2;
var b=0.4-0.3;
a==b//false
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;常用Math
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Math.pow(2,23);//2的23次方
Math.round(0.7);//四舍五入
Math.ceil(0.7);//向上取整
Math.floor(0.7);//向下取整
Math.abs(-5);//绝对值
Math.max(x,y,z);//
Math.min(x,y,z);//
Math.random();//
Math.PI;//
Math.E;//
Math.sqrt();//
Math.sin(0);//
Math.log(10);//
Math.log(100)/Math.LN10;//
Math.exp();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Javascript权威指南学习笔记1：第二章（词法结构）</title>
   <link href="http://http://coolshell.info/blog/2017/08/js%E5%9F%BA%E7%A1%80-2.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/js基础-2</id>
   <content type="html">&lt;h3 id=&quot;js编码&quot;&gt;JS编码&lt;/h3&gt;
&lt;p&gt;JS的编码基于Unicode编码，是ASCII以及Latin-1的超集，支持几乎所有语言；&lt;/p&gt;
&lt;h3 id=&quot;js区分大小写&quot;&gt;js区分大小写&lt;/h3&gt;
&lt;h3 id=&quot;js解析&quot;&gt;js解析&lt;/h3&gt;
&lt;p&gt;JS解析的时候会过滤掉空格，制表符，换页符等；
对于回车符号，如果结尾有分号，会被忽略，否则，会做以下处理：
&lt;strong&gt;如果当前行与下一行不能合在一起被解析，那么当前行会被加上分号&lt;/strong&gt;，例如&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a  
a  
=  
3  
console.log(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会被解析为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a;  
a=3;  
console.log(a);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var p = a+b+f  
(c+d).toString()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会被解析为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var p = a+b+f(c+d).toString(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;其中有2种情况异常：&lt;/strong&gt;
情况1：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return  
true 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会被解析为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return;  
true;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;因此 return 后面不要跟回车；
情况2：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x  
++  
y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会被解析为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x;  
++y;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;分号可省略，省略有风险。在写组件的时候，往往习惯在开头加一个分号，这样可以防止之前没有分号，导致的解析错误。&lt;/p&gt;
&lt;h3 id=&quot;保留字&quot;&gt;保留字&lt;/h3&gt;
&lt;p&gt;js标识符规定以字母、下划线、$开头；
js有很多保留字，不能用于变量命名，例如 class, const, enum, export, extends, import, super, 以及在严格模式下的保留字interface, implements, let, private, public, yield, package, protected, static, 严格模式下并非保留字但不能用于保留字的 arguments, eval;
总之，高级语言中的保留字基本都被js作为保留字了，尽管js目前不一定使用这些保留字。
出于可移植以及易于书写的考虑，一般用ASCII字母和数字来书写标识符，然而js也是可以解析Unicode字符的，这些不常用。&lt;/p&gt;
&lt;h3 id=&quot;特有全局变量及函数&quot;&gt;特有全局变量及函数&lt;/h3&gt;
&lt;p&gt;js有特定的全局变量及函数，用到的时候再进行总结。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Javascript权威指南学习笔记1：第一章</title>
   <link href="http://http://coolshell.info/blog/2017/08/js%E5%9F%BA%E7%A1%80-1.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/js基础-1</id>
   <content type="html">&lt;p&gt;工作一年，对前端有了一些自己的理解，前端知识太多，于是决定从学习基础知识开始，重新将基础知识进行整理，希望弥补漏洞，并温故知新。&lt;/p&gt;

&lt;p&gt;第一章没有太多核心知识，只是对全书进行一个概括性的总结，从js基础语法入手，逐步介绍如何使用js进行web开发，以及中间包含的各种知识，对这一章的学习可以对整个JS有一个清晰的认识。&lt;/p&gt;

&lt;h3 id=&quot;基础知识篇&quot;&gt;基础知识篇&lt;/h3&gt;
&lt;p&gt;js基本语法，包括变量定义、赋值、运算，基本数据类型、数组、对象、方法，面向对象，条件运算，循环运算，正则；&lt;/p&gt;
&lt;h3 id=&quot;进阶篇&quot;&gt;进阶篇&lt;/h3&gt;
&lt;p&gt;如何将JS应用到Web开发，这里涉及到应用规范，加载规范；如何操作Dom，如何与css交互，如何进行事件处理；调试工具；以及为了解决兼容性并且使用简便而出现的各种库；&lt;/p&gt;
&lt;h3 id=&quot;高级篇&quot;&gt;高级篇&lt;/h3&gt;
&lt;p&gt;与服务端交互；数据存储机制；客户端绘图；新应用；&lt;/p&gt;
&lt;h3 id=&quot;终极篇&quot;&gt;终极篇&lt;/h3&gt;
&lt;p&gt;经过前面的学习，对前端开发应该会有清晰的认识，也可以非常流畅的干活了。&lt;/p&gt;

&lt;p&gt;然而，前端并不仅仅这些，
性能优化，模块化一直都是在开发过程中不懈追求的，而平时的学习也应当不断总结不断积累，不断扩展知识面；而今，如React、vue、angular等各个框架日新月异，h5也带来了很多新颖特性，总之，前段就是一条不断学习之路。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我所知道的iframe</title>
   <link href="http://http://coolshell.info/blog/2017/08/html-iframe.html"/>
   <updated>2017-08-19T00:00:00+00:00</updated>
   <id>/blog/2017/08/html-iframe</id>
   <content type="html">&lt;p&gt;iframe在前端开发过程中应用广泛，其主要是将一个页面作为整体引用到一个页面中。一般有以下应用场景&lt;/p&gt;

&lt;h3 id=&quot;1-公司应用系统开发&quot;&gt;1. 公司应用系统开发&lt;/h3&gt;
&lt;p&gt;一般会有一个左侧列表，作为一个框架，每一个目录引用独立的html页面，这样便于每一个页面独立开发。&lt;/p&gt;

&lt;h3 id=&quot;2-引入第三方&quot;&gt;2. 引入第三方&lt;/h3&gt;
&lt;p&gt;当页面需要从第三方引入模块的时候，往往会使用iframe，保证原始页面与第三方之间不冲突。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来，我们聊一聊，iframe中，如何进行事件的绑定&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;iframe的事件绑定&quot;&gt;iframe的事件绑定&lt;/h2&gt;
&lt;h3 id=&quot;1-事件绑定&quot;&gt;1. 事件绑定&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-$('iframe').load(function(){&quot;&gt;	$('iframe').contents().click(function(){console.log(&quot;test1&quot;)});//会为所有iframe绑定事件
	//document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow.document.onclick=function(){console.log(&quot;test”)}//按照序号为每一个iframe绑定事件
	//document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow.onclick=function(){console.log(&quot;test”)}//同上
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;contentWindow用于获取iframe内容，原生写法，这个属性是只读的，iframe本身不能绑定事件，要获取其内容绑定事件，
$(‘iframe’).find(‘body’)//undefined
$(‘iframe’).contents().find(‘body’)//ok
另外，需要等待iframe load成功之后再绑定事件，否则事件绑定失败&lt;/p&gt;
&lt;h3 id=&quot;2-事件委托&quot;&gt;2. 事件委托&lt;/h3&gt;
&lt;p&gt;无法实现，因为事件冒泡到自己的document就会停止，不会继续向上，所以在外层无法检测内层的事件冒泡。&lt;/p&gt;
&lt;h3 id=&quot;3-each&quot;&gt;3. each&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(function () {
    $(&quot;iframe&quot;).each(function () {
        var iframe = $(this);
        iframe.on(&quot;load&quot;, function () { //保证完全加载完成
            console.log(iframe.contents())
            iframe.contents().click(function (event) {
                iframe.trigger(&quot;click&quot;);
            });
        });
        iframe.click(function () {
            console.log(3);
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;4-伪类&quot;&gt;4. 伪类&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.g-content:after{
      content:&quot;&quot;;
      position:absolute;
      z-index:1;
      width:100%;
      height:100%;
      left:0;
      top:0;
}
$(&quot;#j_content&quot;).on(&quot;click&quot;,function(){
    console.log(&quot;test&quot;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;给iframe的父容器添加伪类after，并给其绑定事件，缺点是，ifrmame内部的所有事件都会被遮挡，不会响应。&lt;/p&gt;

</content>
 </entry>
 
 
</feed>