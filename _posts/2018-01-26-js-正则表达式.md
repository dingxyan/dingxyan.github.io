---
layout: post
title:  正则表达式
categories: 前端知识积累
tags: js 正则表达式
---

### 正则表达式概述
正则用于匹配字符串，用于从字符串中检索，当然也可以用于替换；
正则效率高，方便好用
### 基本语法
```
var patt=/pattern/modifiers;
var patt=new RegExp(pattern,modifiers);
```
其中，pattern表示表达式的模式；modifiers表示修饰符，用于表示是否区分大小写，是否全局匹配，是否多行匹配；

### 修饰符
```
i  //是否区分大小写
g  //全局匹配
m  //多行匹配
```
### 元字符
用于匹配单个字符，常用的如下：
```
.      匹配任意字符，除了换行和行结束
^     取非，例如[^0-9]表示非数字；以任意开头，例如/^is/表示以is开头
|      或
\w   任意数字字母下划线，等价[0-9a-zA-Z_]
\W   等价[^0-9a-zA-Z_]
\d    数字，等价[0-9]
\D   非数字，等价[^0-9]
\s    任意空白字符，等价[\f\n\r\t\v]
\S   等价[^\f\n\r\t\v]
\b   匹配单词边界，即单词需要以匹配的模式开头或者结尾，例如字符串The cat scattedred his food all over the room, 正则表达式为/\bcat\b/，将会匹配 cat，而scattedred中的cat不会被匹配，\b表示匹配一个位置，这个位置位于一个能够用来构成单词的字符；
\B   匹配非单词边界，例如 nine-digit color - coded ,\B-\B 将会匹配color - coded中间的-，因为该-前后都不是单词边界
\0   NULL字符
\n   换行
\f   换页
\r   回车
\t   制表Tab
\v   垂直制表
\xxx  八进制，例如 var patt1=/\127/g; 匹配W
\xdd  十六进制，例如var patt1=/\x57/g; 匹配W
\uxxxx  十六进制的unicode编码，例如var patt1=/\u0057/g;
[    表示字符集合的开始
]    表示字符集合结束
```
##### 说明：
1. 元字符只能匹配单个字符；
2. 字符集合中的元字符
	例如. [ 等不需要转译；例如[\w\.]等价[\w.];
3. ^ 用于字符集合[]的时候，要放在[]内部，表示对内部描述的整体集合取非；
4. 量词

	由于元字符只能表示单个字符，那么如何表示多个字符？
	```
	+        匹配一个或者多个
	*        匹配0个或者多个
	?        匹配0个或者1个
	{X}      匹配X个
	{X,Y}    匹配大于等于X个，小于等于Y个
	{X,}     匹配大于等于X个
	^        取非，例如[^0-9]表示非数字；以任意开头，例如/^is/表示以is开头
	$        以任意结尾，例如/is$/表示以is结尾
	?=       匹配任何其后紧跟指定字符的字符串，例如/is(?=all)/表示紧接all的is，即向前查找，从all向前查找匹配的is，但是不包括all
	?!       匹配任何其后没有紧跟指定字符的字符串，例如/is(?!all)/表示后面没有紧接all的is
	?<=      向后查找，例如，(?<=\$)[0-9.]+ 可匹配 $12.123，以$开头，但是不包括$
	?<!
	```

##### 说明：贪婪型及懒惰型元字符
\+ \* {X,} 这些量词，都表示至少多少个，所以会出现过度匹配的情况，例如
```
var str = "<b>sdasd</b>sdau<b>dhuas</b>"; 
var reg = /<[Bb]>.*<\/[Bb]>/g;
```
匹配结果： "<b>sdasd</b>sdau<b>dhuas</b>"

```
var str = "<b>sdasd</b>sdau<b>dhuas</b>"; 
var reg = /<[Bb]>.*?<\/[Bb]>/g;
```
匹配结果： "<b>sdasd</b>"   "<b>dhuas</b>"

即在 + * {X,}  后添加? ，成为懒惰型

### 方法
```
test()
match()
exec()
例如：
var reg = /\d/;
var str = "abcd123";
reg.test(str);//是否匹配，返回true或者false
str.match(reg);//返回所有匹配，返回数组
reg.exec(str);//返回第一次出现，返回数组
str.replace(reg,function(par1,par2){//可？以执行回调函数
	console.log(6786986,par1,par2)
});
```
### 特殊
分行匹配模式：(?m) 

使得正则表达式引擎将行分隔符当作一个字符串分隔符来对待；在分行匹配模式下，^匹配正常的字符串开头，还匹配行分隔符（换行符）后面的开始位置（这个位置是不可见的）；$匹配正常的字符串结尾，还将匹配行分隔符（换行符）后面的结束位置；

例如(?m)^\s*//.*$将匹配所有以//开头的注释；

### 表达式
前面提到，元字符都是一个一个来匹配的，比如/abc{3}/, 会匹配 abccc, 那么匹配abcabcabc的话应该怎么做呢，此时需要对一个表达式进行重复，即/(abc){3}/；另外，表达式也可以嵌套；表达式需要用()括起来；

### 回溯
直接举例：<[hH]([1-6])>.*?<\/[hH]\1>匹配1级标题到6级标题；

其中\1表示第一个表达式，同理\2 表示第二个表达式；这里的第一个表达式是([1-6])；

同理正则表达式为<([hH])([1-6])>.*?<\/[hH]\2>与上述等价；

### 条件(实测，chrome, safari, firefox 不支持)
用于某些条件下需要匹配，但是在某些条件下不需要匹配，例如在有左括号的时候，要求有右括号，当没有左括号的时候要求没有右括号；

例子1：/(\()?\d{3}(?}\(1)\))/匹配(322), (123), 342, 234等；

例子2: /(\()?\d{3}(?}\(1)\)|-)\d{3}/匹配(231)223, 343-333等，当有括号的时候，后面匹配任意三位数，当没有括号的时候，后面匹配-加上任意三位数。
var reg = /\d{3}(-\d{3})?/g;(支持)

