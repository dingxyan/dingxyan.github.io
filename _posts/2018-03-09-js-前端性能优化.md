---
layout: post
title: 前端性能优化
categories: 前端知识积累
tags: js 性能优化
---


> 前端性能优化可以从以下三个方面考虑：
请求（与服务端交互），渲染（页面渲染速率），计算（包括渲染过程的计算，以及交互过程的计算）。

### 减少http请求
- 雪碧图
- 压缩资源
- 合并js，合并css
- 缩略图

http/1,1.1 同时并发请求6个左右，http2的出现，使得可以同时发送多个请求（无限制），效率高，不需要刻意将多个数据合并成一个
### 减少dom操作，语义化dom
- 缓存dom检索结果
- 将数据使用js对象保存，而非保存在dom

### 减少重绘及回流

repaint: 当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做**重绘**。

reflow: 当render树中的一部分或者全部因为大小边距等问题发生改变而需要重建的过程叫做**回流**；

因此，回流一定会引起重绘。

例如对dom重新设置大小，边框等等，都需要回流，而浏览器会将多个计算放到一个队列，在一个特定时机去一次性的计算队列里的信息，执行一次回流和重绘；然而当我们需要获取边距等信息的时候，浏览器会认为，回流队列里的信息是会影响我们要获取的值，所以，此时浏览器会先执行一次回流，再去计算。
- 减少直接对style的操作，尽量使用添加class或者减少class
- 将多个会引起回流的计算放到一起操作
- 减少获取width, height, top, offsetScroll等值
- 定位，移出文档流
- 尽量不要实用table

### 事件代理
尽量使用事件代理，而非绑定多个事件

### 服务器失效时间，配置ETag 
对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期） 
对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求
浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端内容需要缓存多长时间。如果你使用的是Apache服务器，可以使用ExpiresDefault来设定相对当前日期的过期时间。

### 浏览器缓存策略
1. 头信息
    1. Expires
        响应头 
        例如: Expires:Fri, 11 Nov 2016 06:56:15 GMT
        在此日期之前，客户端都会认为缓存是有效的
    2. Cache-Control
        响应头 
        例如: Cache-Control:max-age=43200
        一个相对的秒数，表示从现在起，43200秒内缓存都是有效的，优先级高于Expires；Cache-Control/Expires的优先级要高于Last-Modified/ETag；
    3. Last-Modified
        响应头
        例如：Last-Modified:Fri, 06 Nov 2015 16:55:40 GMT
        Last-Modified把Web组件的最后修改时间告诉客户端，客户端会发送请求到服务端询问是否有修改，从而确认使用本地缓存文件还是从服务端获取文件；
    4. ETag
        ETag优先级高于Last-Modified；如果ETag一致，则比较Last-Modified，从而决定是否返回304；
    5. If-Modified-Since
        请求头
        例如：If-Modified-Since:Fri, 06 Nov 2015 16:55:40 GMT
        客户端在请求此Web组件的时候，会把上次服务端响应的最后修改时间作为If-Modified-Since的值发送给服务器，
        服务器可以通过这个值来判断是否需要重新发送，如果不需要，就简单的发送一个304状态码，客户端将从缓存里直接读取所需的Web组件
    
2. 浏览器的刷新方式
    - F5：不允许浏览器直接使用本地缓存，而是与服务端协商，确认哪些需要从缓存读取，哪些需要从服务端重新获取；
    - Ctrl+F5：强制从服务器取文件，不会走缓存机制；
    - 地址栏里回车：优先从缓存中读取文件；


- 浏览器请求资源a    -->    200    -->    在响应头添加一个Last-Modified    -->    浏览器缓存a并缓存Last-Modified
- 浏览器再次请求资源a（F5）    -->   浏览器携带If-Modified-Since Cache-Control:max-age=0    -->    服务器根据If-Modified-Since判断如何相应（304 or 200）
- 浏览器再次请求资源a（Ctrl+F5）    -->    浏览器携带Cache-Control:no-cache, 不携带If-Modified-Since    -->    200
- 浏览器再次请求资源a（浏览器回车）    -->    200(from cache)

### http状态码
1. 1**，表示服务端接收到了客户端的请求，需要客户端继续发送请求；
2. 2**，表示请求成功；
    1. 200，请求成功
3. 3**，表示重定向，需要更进一步操作以完成请求；
    1. 301，永久移动，请求的资源已经永久移动到新的url；
    2. 302，临时移动，资源只是临时移动；
    3. 304，未修改，可以访问缓存内容，客户端需要提供头信息给服务端用于比较日期，确认没有改动后返回304；
    4. 305，代理，所有请求的资源必须通过代理访问；
4. 4**，表示客户端错误；
    1. 403，服务端理解请求，但是拒绝执行；
    2. 404，无法找到；
5. 5**，表示服务端错误；
    1. 500，服务端内部出错；
    2. 501，服务端不支持请求的功能；
    3. 502，网关错误；
    4. 503，超载或者系统维护，无法完成请求；
    5. 504，网关超时；

### CDN
自己本身有一个服务器，再实用CDN分布式处理，用户可以从离自己最近的节点获取资源。

### 分域名部署
每个域名下一次可以并发请求的数量是有限的，所以分域名部署，可以增加并发请求的文件数量；然而http2允许并发的数据可以达到几百条，这种方式不再实用。

### 减少字符串连接(新浏览器性能提高了很多，这一项现在不成立了，很难去确定哪种方式效果更好)
js中，字符串具有不变性，例如

```
var str1 = "abc";
str1 += "def";
```
上述代码执行步骤：先开辟一个空间保存abc；取出来abc，与def连接，再开辟一个空间保存abcdef；回收保存abc的空间（回收时间未知）。

因此字符串累加会多次开辟新空间，并回收原始空间，浪费时间。

> 针对前端性能的优化，前端应该尽量减少计算，但是现代浏览器的计算能力很强，对于一些在服务端计算很复杂的操作，比如涉及多次查询数据库的操作，也可以将计算放在前端，要相信前端的计算能力，因此优化跟开发效率是一个折中的选择。如果为了优化，增加开发成本，有的时候也是得不偿失的。
> 对于一些用户端的网页，能快速呈现给用户是第一要旨；而对于一些内部系统，有的时候等待网页的加载也是可以接受的。

