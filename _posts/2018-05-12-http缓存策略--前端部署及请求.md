---
layout: post
title:  http缓存策略--前端部署及请求
categories: 前端知识积累
tags: http 缓存 前端请求
---

### 缓存规则

浏览器的缓存规则由*响应头*中的Cache-Control以及Expires决定，前者优先级大于后者，会覆盖后者；
1. Expires

值为一个时间，表示在该时间之前，认为有效；

例如: Expires:Fri, 11 Nov 2016 06:56:15 GMT 在此日期之前，客户端都会认为缓存是有效的；http1.1版本基本不再使用;

3. Cache-Control

    不同取值决定不同的缓存规则：

    1. public：浏览器及代理都可以缓存；
    2. private：只有浏览器可以缓存；
    3. no-cache：浏览器及代理都可以缓存，但是使用该资源的时候必须走缓存机制；
    4. max-age=<seconds>：缓存的最大周期，超过这个时间将失效，时间相对于请求时间；
    5. 响应头头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求。
    6. no-store: 所有内容都不会缓存

更多请参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control；

### 缓存机制
1. If-Modified-Since  Last-Modified
    1. Last-Modified 
    
        响应头 例如：Last-Modified:Fri, 06 Nov 2015 16:55:40 GMT;
        
        Last-Modified把Web组件的最后修改时间告诉客户端，客户端会发送请求到服务端询问是否有修改，从而确认使用本地缓存文件还是从服务端获取文件；
    2. If-Modified-Since
    
        请求头 例如：If-Modified-Since:Fri, 06 Nov 2015 16:55:40 GMT；
        
        客户端在请求此Web组件的时候，会把上次服务端响应的最后修改时间作为If-Modified-Since的值发送给服务器，服务器可以通过这个值来判断是否需要重新发送，如果不需要，就简单的发送一个304状态码，客户端将从缓存里直接读取所需的Web组件;

缺点：当服务端使用负载均衡，会将资源保存在不同集群，而不同服务器系统时间不一定一致；每次请求资源的时候，不一定是从哪一台服务器获取的，此时尽管文件未修改，请求的If-Modified-Since与服务端的Last-Modified也不一定一致，会导致频繁更新；
2. If-None-Match   ETag
    1. ETag 
        ETag优先级高于Last-Modified；如果ETag一致，则返回304；
    2. If-None-Match 
        与ETag对比
（有ETag先比较ETag和If-None-Match，不一致的话直接返回新资源；一致的话返回304.）

### 用户行为对缓存机制的影响

用户操作 | Cache-Control/Expires | Last-Modified/Etag
---|---|---
地址栏回车 | 有效 | 有效
页面连接跳转 | 有效 | 有效
新开窗口 | 有效 | 有效
前进后退 | 有效 | 有效
F5刷新 | 无效 | 有效
Ctrl+F5 | 无效 | 无效
说明：

1. 如果响应头设置了Cache-Control 为public

F5 必须走缓存协商机制，从而判断是从服务端获取数据还是从本地缓存或者代理服务器获取；Ctrl+F5要求必须从服务端重新获取数据；其他操作都是可以直接从本地缓存或者代理服务器获取（如果缓存中数据有效则直接获取，否则要重新从服务端获取）；

2. 如果响应头设置了Cache-Control private

F5 必须走缓存协商机制，从而判断是从服务端获取数据还是从本地缓存获取；Ctrl+F5要求必须从服务端重新获取数据；其他操作都是可以直接从缓存获取（如果缓存中数据有效则直接获取，否则要重新从服务端获取）；

3. 如果响应头设置了Cache-Control 为no-catch

所有操作都需要直接从服务端获取；


### 其他名词说明
单个用户缓存，共享缓存，客户端，代理服务器

server ------  代理服务器 ------ 用户
server ------ 用户

### http缓存策略总结
步骤：
1. 根据响应头，以及用户行为，决定使用哪一种缓存策略：直接使用本地缓存中有效的数据，如果无效还需要重新获取；进行缓存协商；不使用缓存，直接从服务器获取数据；

2. 直接使用本地缓存

判断本地缓存数据是否有效，有效的话直接使用；

3. 缓存协商的流程：
    1. 客户端发起http请求，携带 If-Modified-Since 或者 ETag；
    2. 服务端根据优先级，计算，返回304或者200（304表示客户端使用本地缓存，200表示资源直接从服务器返回）；

### 前端部署
1. 不部署CDN
    1. 静态资源跟服务端资源都部署到服务器
    2. 优点：简单方便
    3. 缺点：针对访问量大的需求，影响性能，浪费带宽
2. 静态资源部署CDN
    1. 问题：上线静态资源的时候会引用旧资源
    2. 解决：加版本号
    3. 优点：利用CDN资源，提高性能
    4. 新的问题：已经缓存的资源如果没有修改，会有所浪费
    5. 解决：利用数据摘要算法做版本号
    6. 新的问题：修改静态资源的同时，修改html模板；如果先上html，在这个期间会加载老的静态资源，导致页面错乱；如果线上静态资源，此时仍然访问的老资源，并且这个错乱是很难手动去解决的，如果解决的话跟缓存策略是相违背的。
    7. 解决方案：半夜上线，错过访问高峰期；保持html模板不变（治标不治本）;使用“数据摘要算法”，作为文件名字，并且修改引用名称，而不是作为版本号，然后前后端独立部署，当然部署过程中访问还是会有问题，只不过部署完成后问题会解决。

