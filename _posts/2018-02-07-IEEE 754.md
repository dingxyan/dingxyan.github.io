---
layout: post
title: js中浮点数的表示及计算--IEEE 754
categories: 前端知识积累
tags: 浮点数 IEEE-754
---
> 重拾IEEE 754，才发现，本科学习的东西都还给老师了。于是翻出以前的课件及资料，重新学习，整理。

### 重点概念

由于数字在机器里都是以机器数来存储的，那么首先需要知道，机器数都有哪些，以及它们是如何计算的。

由于IEEE 754描述的是有符号的浮点数，因此以下概念介绍中都尽量以有符号的浮点数为例（无符号以及整数都比这个简单）。

#### 原码
```
+0.0111     =>    0,0.0111
-0.0111      =>    1,0.0111
逗号前表示正负，0表示正数，1表示负数；
原码计算方式：正数符号位取0，数值位不变；负数符号位取1，数值位不变。
说明：原码是最接近真实数值的一种表示方式，然而计算机希望只做加法运算，那么针对负数，原码无法满足需求。
```
#### 反码
```
+0.0111     =>    0,0.0111
-0.0111      =>    1,0.0111
反码计算方法：正数的反码与原码相同；负数的反码为原码除了符号位外，其余位置取反。
```

#### 补码
```
+0.0111     =>    0,0.0111
-0.0111      =>    1,1.1001
补码计算方式：整数的补码与原码相同；负数的补码为原码除了符号位外，其他位置取反，并在末尾加1。
说明：对于5位精度二进制数的加减来说，
1111-0001=（01111）-（10001）(原码)=（01111）+（11111）(补码)，解决了计算机只计算加法的问题。
```

#### 移码
```
+0111     =>    1,0111
-0111      =>    0,1001
移码计算方式：x为真值，移码=x+2^n; 即，移码与补码符号位相反。
说明：无论是原码还是反码还是补码，整数符号位都是0，负数符号位都是1，有一种负数比正数大的假象；因此引入移码，可以直观的比较数值的大小。
```

#### 阶码
```
+0111     =>    1,0110
-0111      =>    0,1000
阶码计算方式：移码减1.
```

### IEEE 754 组成

FloatPoinNum = (-1)^{S}\times(1.M)\times2^{E}

其中，S表示符号，1表示负数，0表示正数；M表示尾数部分；E表示阶码。

32位精度：

1位符号位+8位指数位+23位尾数部分

64位精度：

1位符号位+11位指数位+52位尾数部分

其中，符号位使用阶码表示，尾数部分使用补码表示。

注意：尾数部分表示1.xxxx,在符号位与尾数中间有个隐藏的 "1."被省略了。

### IEEE 754 浮点数表示范围(以32位精度为例)

##### 阶码部分表示范围

```
真值范围：-(2^7-2)~(2^7-1)
阶码范围：
-(2^7-2)        =>    0000 0001
……
0                    =>    0111 1111
1                    =>    1000 0000
2^7-1             =>    1111 1110
```

##### 尾数部分表示范围

```
真值范围：1.0～1.11111111……
```
**因此，**
```
最小正数：符号位为0，阶码为1，尾数部分为1.0

1.0*2^(-126)

最大正数：符号位为0，阶码为 1111 1110，尾数部分为1.111111……

(2-0.1*2^(-22))*(2^127)

最小负数：符号位为0，阶码为 1111 1110，尾数部分为1.111111……

-(2-0.1*2^(-22))*(2^127)

最大负数：符号位为0，阶码为1，尾数部分为1.0

-1.0*2^(-126)
```

### js中IEEE 754 对数字表示方式(以32位精度为例)
1. 0
```
IEEE 754规定阶码为0000 0000的时候，尾数部分都是0，此时表示0，因此，0的机器数为：
+0: 0 0000 0000 0000 0000 0000 0000 0000 000
-0: 1 0000 0000 0000 0000 0000 0000 0000 000
阶码0000 0000，转换为移码为 0000 0001，转换为补码为1000 0001，转换为原码为1111 1111，即-(2^7-1)=-127.
因此其真值为： (-1)^{S}\times2^{-127} ，即 -0为 -2^{-127} , +0为 2^{-127} 
```
2. 无穷
```
IEEE 754规定阶码为 1111 1111，尾数部分都是0表示无穷，因此无穷的机器数为：
正无穷： 0 1111 1111 0000 0000 0000 0000 0000 000
负无穷： 1 1111 1111 0000 0000 0000 0000 0000 000
```
3. NaN
```
IEEE 754规定阶码为 1111 1111，尾数部分不为0，表示非数字，即NaN.
```

### ES6 中新特性

#### 最小精度
```
由于浮点数在计算过程中，往往会存在误差。
ES6在Number对象上增加了一个极小误差Number.EPSILON，用来表示最小精度。最小精度的值为1与大于1最小的浮点数之差。
对于64位精度来说，大于1的最小浮点数位：1.000……0001，小数点后面有51个0，这个值减去1，为2^(-52)，所以Number.EPSILON=2^(-52)。在计算过程中，误差小于这个值的时候，可以认为不存在误差，因为已经超出了计算机的处理范围。
```

#### 安全整数

以64位精度为例，JavaScript 能够准确表示的整数范围在-2^(-53)到2^(53)之间（不含两个端点），超过这个范围，无法精确表示这个值。
假设浮点数位数部分有2位，那么，
	
```
1表示为 1.00*2^0
2表示为1.00*2^1
3表示为1.10*2^1
……
6表示为1.10*2^2
7表示为1.11*2^2
8表示为1.000*2^3
```
然而尾数只能有2位，因此最后一位的0是不准确的，所以对于大于等于8的整数，将无法精确表达，因此其表示范围为大于-2^(-2)，小于2^(2).

ES6中引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER两个常量，分别表示整数范围的上限和下限，当超出这个范围的，会被认为无法精确表达一个整数；

Number.isSafeInteger()用于判断一个整数是否在安全范围内。

### 参考文章

1. 《计算机组成原理》唐朔飞
2. [IEEE 754 - Wikipedia](https://en.wikipedia.org/wiki/IEEE_754)
3. [IEEE754浮点数的表示方法 - CSDN博客](https://blog.csdn.net/k346k346/article/details/50487127)
4. [ECMAScript 6入门](http://es6.ruanyifeng.com/#docs/number)
